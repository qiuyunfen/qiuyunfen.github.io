webpackJsonp([5],{0:function(e,t,n){e.exports=n(147)},42:function(e,t){e.exports=function(e,t){t.displayName="ReactRouterProxy",t.getInitialState=function(){return{component:this.loadComponent()}},t.componentDidMount=function(){this.___isMounted=!0,this.state.component||this.loadComponent(function(e){this.___isMounted&&this.setState({component:e})}.bind(this))},t.componentWillUnmount=function(){this.___isMounted=!1},t.render=function(){var t=this.state.component;return t?e.createElement(t,this.props,this.props.children):this.renderUnavailable?this.renderUnavailable():null}}},147:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}var r=n(1),u=o(r),a=n(97),i=n(64),s=n(10),l=n(94),c=n(150),d=o(c),T=n(151),f=o(T);n(152);var P=(0,s.useRouterHistory)(l.createHashHistory)({queryKey:!1}),p=(0,f["default"])();(0,a.render)(u["default"].createElement(i.Provider,{store:p},u["default"].createElement(s.Router,{history:P,routes:d["default"]})),document.getElementById("app"))},148:function(e,t,n){"use strict";function o(){var e=arguments.length<=0||void 0===arguments[0]?r:arguments[0],t=arguments[1];switch(t.type){case"EDIT_ARTICLE":return e.map(function(e){return e.id==t.id?Object.assign({},e,{show:t.isShow}):e});case"CLEAR_ARTICLES":return r;default:return e}}Object.defineProperty(t,"__esModule",{value:!0}),t["default"]=o;var r=(n(96),[{id:1,title:"为什么我们应该尽快支持 ALPN？",category:"ess",date:"May 26, 2016",show:!1,content:"昨天有位朋友在微信上发过来一个链接：The day Google Chrome disables HTTP/2 for nearly everyone: May 31st, 2016（中文翻译）。看标题这篇文章说的是 Google Chrome 即将大面积禁用 HTTP/2，这究竟是怎么回事呢？本文为你揭晓答案。先来回顾一下，浏览器在访问 HTTPS 网站时，如何得知服务端是否支持 HTTP/2？答案是借助 HTTP/2 的协议协商机制：在 HTTP/2 Over HTTP 中，可以使用 HTTP 的 Upgrade 机制进行协商；而对于 HTTP/2 Over TLS，可以使用 TLS 的 NPN 或 ALPN 扩展来完成协商。HTTP/2 的这两种协商方式，不了解的同学请看《谈谈 HTTP/2 的协议协商机制》，这里不再赘述。当前所有浏览器，都只支持 HTTP/2 Over TLS。也就是说，浏览器和服务端都支持 NPN 或 ALPN 协商，是用上 HTTP/2 的大前提。本文重点讨论 NPN 和 ALPN。"},{id:2,title:"为什么我们应该尽快支持 ALPN？",category:"html",date:"May 29, 2016",show:!1,content:"昨天有位朋友在微信上发过来一个链接：The day Google Chrome disables HTTP/2 for nearly everyone: May 31st, 2016（中文翻译）。看标题这篇文章说的是 Google Chrome 即将大面积禁用 HTTP/2，这究竟是怎么回事呢？本文为你揭晓答案。先来回顾一下，浏览器在访问 HTTPS 网站时，如何得知服务端是否支持 HTTP/2？答案是借助 HTTP/2 的协议协商机制：在 HTTP/2 Over HTTP 中，可以使用 HTTP 的 Upgrade 机制进行协商；而对于 HTTP/2 Over TLS，可以使用 TLS 的 NPN 或 ALPN 扩展来完成协商。HTTP/2 的这两种协商方式，不了解的同学请看《谈谈 HTTP/2 的协议协商机制》，这里不再赘述。当前所有浏览器，都只支持 HTTP/2 Over TLS。也就是说，浏览器和服务端都支持 NPN 或 ALPN 协商，是用上 HTTP/2 的大前提。本文重点讨论 NPN 和 ALPN。"}])},149:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(38),u=n(148),a=o(u),i=(0,r.combineReducers)({article:a["default"]});t["default"]=i},150:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),u=o(r),a=n(10),i=n(174),s=o(i),l=n(171),c=(o(l),n(173)),d=(o(c),n(172));o(d);t["default"]=u["default"].createElement(a.Route,{component:s["default"],path:"/"})},151:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){var t=(0,u.createStore)(i["default"],e);return t}Object.defineProperty(t,"__esModule",{value:!0}),t["default"]=r;var u=n(38),a=n(149),i=o(a)},152:function(e,t){},171:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(2,function(){var t=n(55);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(42);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},172:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(4,function(){var t=n(33);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(42);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},173:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(3,function(){var t=n(22);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(42);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},174:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(1,function(){var t=n(145);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(42);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u}});