webpackJsonp([5],{0:function(e,t,n){e.exports=n(146)},44:function(e,t){e.exports=function(e,t){t.displayName="ReactRouterProxy",t.getInitialState=function(){return{component:this.loadComponent()}},t.componentDidMount=function(){this.___isMounted=!0,this.state.component||this.loadComponent(function(e){this.___isMounted&&this.setState({component:e})}.bind(this))},t.componentWillUnmount=function(){this.___isMounted=!1},t.render=function(){var t=this.state.component;return t?e.createElement(t,this.props,this.props.children):this.renderUnavailable?this.renderUnavailable():null}}},146:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}var r=n(1),u=o(r),a=n(96),i=n(63),s=n(10),l=n(93),c=n(149),d=o(c),T=n(150),f=o(T);n(151);var P=(0,s.useRouterHistory)(l.createHashHistory)({queryKey:!1}),p=(0,f["default"])();(0,a.render)(u["default"].createElement(i.Provider,{store:p},u["default"].createElement(s.Router,{history:P,routes:d["default"]})),document.getElementById("app"))},147:function(e,t,n){"use strict";function o(){var e=arguments.length<=0||void 0===arguments[0]?r:arguments[0],t=arguments[1];switch(t.type){case"EDIT_ARTICLE":return e.map(function(e){return e.id==t.id?Object.assign({},e,{show:t.isShow}):e});case"CLEAR_ARTICLES":return r;default:return e}}Object.defineProperty(t,"__esModule",{value:!0}),t["default"]=o;var r=(n(95),[{id:1,title:"为什么我们应该尽快支持 ALPN？",category:"ess",date:"May 26, 2016",show:!1,content:"昨天有位朋友在微信上发过来一个链接：The day Google Chrome disables HTTP/2 for nearly everyone: May 31st, 2016（中文翻译）。看标题这篇文章说的是 Google Chrome 即将大面积禁用 HTTP/2，这究竟是怎么回事呢？本文为你揭晓答案。先来回顾一下，浏览器在访问 HTTPS 网站时，如何得知服务端是否支持 HTTP/2？答案是借助 HTTP/2 的协议协商机制：在 HTTP/2 Over HTTP 中，可以使用 HTTP 的 Upgrade 机制进行协商；而对于 HTTP/2 Over TLS，可以使用 TLS 的 NPN 或 ALPN 扩展来完成协商。HTTP/2 的这两种协商方式，不了解的同学请看《谈谈 HTTP/2 的协议协商机制》，这里不再赘述。当前所有浏览器，都只支持 HTTP/2 Over TLS。也就是说，浏览器和服务端都支持 NPN 或 ALPN 协商，是用上 HTTP/2 的大前提。本文重点讨论 NPN 和 ALPN。"},{id:2,title:"为什么我们应该尽快支持 ALPN？",category:"html",date:"May 29, 2016",show:!1,content:"昨天有位朋友在微信上发过来一个链接：The day Google Chrome disables HTTP/2 for nearly everyone: May 31st, 2016（中文翻译）。看标题这篇文章说的是 Google Chrome 即将大面积禁用 HTTP/2，这究竟是怎么回事呢？本文为你揭晓答案。先来回顾一下，浏览器在访问 HTTPS 网站时，如何得知服务端是否支持 HTTP/2？答案是借助 HTTP/2 的协议协商机制：在 HTTP/2 Over HTTP 中，可以使用 HTTP 的 Upgrade 机制进行协商；而对于 HTTP/2 Over TLS，可以使用 TLS 的 NPN 或 ALPN 扩展来完成协商。HTTP/2 的这两种协商方式，不了解的同学请看《谈谈 HTTP/2 的协议协商机制》，这里不再赘述。当前所有浏览器，都只支持 HTTP/2 Over TLS。也就是说，浏览器和服务端都支持 NPN 或 ALPN 协商，是用上 HTTP/2 的大前提。本文重点讨论 NPN 和 ALPN。"}])},148:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(40),u=n(147),a=o(u),i=(0,r.combineReducers)({article:a["default"]});t["default"]=i},149:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),u=o(r),a=n(10),i=n(173),s=o(i),l=n(170),c=(o(l),n(172)),d=(o(c),n(171));o(d);t["default"]=u["default"].createElement(a.Route,{component:s["default"],path:"/"})},150:function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){var t=(0,u.createStore)(i["default"],e);return t}Object.defineProperty(t,"__esModule",{value:!0}),t["default"]=r;var u=n(40),a=n(148),i=o(a)},151:function(e,t){},170:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(2,function(){var t=n(57);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(44);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},171:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(3,function(){var t=n(34);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(44);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},172:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(4,function(){var t=n(23);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(44);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u},173:function(e,t,n){var o,r=n(1),u={loadComponent:function(e){return o?e&&e(o):n.e(1,function(){var t=n(144);o=t.__esModule?t["default"]:t,e&&e(o)}),o}},a=n(44);a(r,u),e.exports=r.createClass(u),e.exports.Mixin=u}});